<?php

namespace youconix\core\ORM\database;

/**
 * General database connection layer
 * 
 * @since 1.0
 */
abstract class GeneralDAL implements \DAL
{

  /**
   *
   * @var \Settings
   */
  protected $settings;
  protected $obj_connection;
  protected $query;
  protected $s_query;
  protected $obj_query;
  protected $bo_connection;
  protected $s_lastDatabase;
  protected $i_id;
  protected $i_affected_rows;
  protected $bo_transaction = false;
  protected $a_bindedKeys = [];
  protected $a_bindedTypes = [];
  protected $a_bindedValues = [];

  /**
   * Loads the binded parameters class
   *
   * @param \Settings $settings
   */
  public function __construct(\Settings $settings)
  {
    $this->settings = $settings;
  }

  /**
   * Destructor
   */
  public function __destruct()
  {
    if ($this->bo_connection) {
      $this->connectionEnd();
    }

    $this->settings = null;
    $this->obj_connection = null;
    $this->obj_query = null;
    $this->bo_connection = null;
    $this->s_lastDatabase = null;
    $this->i_id = null;
    $this->i_affected_rows = null;
    $this->bo_transaction = null;
  }

  /**
   * Returns if the object schould be treated as singleton
   *
   * @return boolean True if the object is a singleton
   */
  public static function isSingleton()
  {
    return true;
  }

  /**
   * Resets the internal query cache.
   */
  public function reset()
  {
    if (is_object($this->obj_query) && !$this->bo_transaction) {
      $this->clearResult();
    }

    $this->query = null;
    $this->s_query = '';
    $this->obj_query = null;
    $this->i_id = - 1;
    $this->i_affected_rows = - 1;
    $this->a_bindedKeys = [];
    $this->a_bindedTypes = [];
    $this->a_bindedValues = [];
  }

  /**
   * Returns the ID generated by a INSERT-command
   *
   * @return int The generated id
   */
  public function getId()
  {
    return $this->i_id;
  }

  /**
   * Returns numbers of rows affected generated by a UPDATE or DELETE command
   *
   * @return int The requested id
   */
  public function affected_rows()
  {
    return $this->i_affected_rows;
  }

  /**
   * Returns or there is a connection to the database
   *
   * @return boolean True if there is a connection with the DB, false if is not
   */
  public function isConnected()
  {
    return $this->bo_connection;
  }

  /**
   * Excequetes the given query on the selected database
   *
   * @deprecated Use prepare instead
   *
   *             @para string $s_query The query to excequte
   *
   * @throws DBException if no connection to the database exists
   * @throws DBException in case of a SQL error
   */
  public function query($s_query)
  {
    $this->queryBinded($s_query, [], []);
  }

  /**
   * Excequetes the given query on the selected database with binded parameters
   *
   * @deprecated Use prepare instead
   *
   * @param string $s_query
   *            to excequte
   * @param array $a_types
   *            types : i (int) ,d (double) ,s (string) or b (blob)
   * @param array $a_values
   *            values
   * @throws Exception if the arguments are illegal
   * @throws DBException when the query failes
   */
  public function queryBinded($s_query, $a_types, $a_values)
  {
    $this->prepare($s_query);

    if (!is_array($a_types))
      $a_types = [
	  $a_types
      ];
    if (!is_array($a_values))
      $a_values = [
	  $a_values
      ];

    $this->a_bindedTypes = $a_types;
    $this->a_bindedValues = $a_values;

    $this->exequte();
  }

  /**
   * Binds a string value
   *
   * @param string $s_field
   *            The field name
   * @param string $s_value
   *            The value
   * @return \DAL
   */
  public function bindString($s_field, $s_value)
  {
    $this->bind($s_field, $s_value, 's');

    return $this;
  }

  /**
   * Binds an integer value
   *
   * @param string $s_field
   *            The field name
   * @param float $i_value
   *            The value
   * @return \DAL
   */
  public function bindInt($s_field, $i_value)
  {
    $this->bind($s_field, $i_value, 'i');

    return $this;
  }

  /**
   * Binds a float value
   *
   * @param string $s_field
   *            The field name
   * @param float $fl_value
   *            The value
   * @return \DAL
   */
  public function bindFloat($s_field, $fl_value)
  {
    $this->bind($s_field, $fl_value, 'f');

    return $this;
  }

  /**
   * Binds a binary value
   *
   * @param string $s_field
   *            The field name
   * @param binary $value
   *            The value
   * @return \DAL
   */
  public function bindBlob($s_field, $value)
  {
    $this->bind($s_field, $value, 'b');

    return $this;
  }

  private function bind($s_field, $value, $s_type)
  {
    if (!array_key_exists(':' . $s_field, $this->a_bindedKeys)) {
      throw new \DBException('Trying to bind to unknown key ' . $s_field);
    }
    $i_pos = $this->a_bindedKeys[':' . $s_field];
    $this->a_bindedTypes[$i_pos] = $s_type;
    $this->a_bindedValues[$i_pos] = $value;
  }

  /**
   * Analyses the given table
   *
   * @param string $s_table
   *            table name
   * @return boolean if the table is OK, otherwise false
   */
  public function analyse($s_table)
  {
    $this->query("ANALYZE TABLE " . $s_table);

    $a_result = $this->fetch_assoc();
    if ($a_result[0]['Msg_text'] != 'OK' && $a_result[0]['Msg_text'] != 'Table is already up to date') {
      return false;
    }

    return true;
  }

  /**
   * Repairs the given table
   *
   * @param string $s_table
   *            table name
   * @return boolean if the table repair succeeded, otherwise false
   */
  public function repair($s_table)
  {
    $this->query("REPAIR TABLE " . $s_table);

    $a_result = $this->fetch_assoc();
    
    if ($a_result[0]['Msg_text'] == "The storage engine for the table doesn't support repair") {
      return true;
    }
    
    if ($a_result[0]['Msg_text'] != 'OK') {
      return false;
    }

    return true;
  }

  /**
   * Optimizes the given table
   *
   * @param string $s_table
   *            table name
   */
  public function optimize($s_table)
  {
    $this->query("OPTIMIZE TABLE " . $s_table);

    $a_result = $this->fetch_assoc();

    if ($a_result[0]['Msg_text'] == 'Table does not support optimize, doing recreate + analyze instead') {
      return true;
    }

    if ($a_result[0]['Msg_text'] != 'OK' && $a_result[0]['Msg_text'] != 'Table is already up to date') {
      return false;
    }

    return true;
  }

  /**
   * Returns the current loaded database
   *
   * @return string
   */
  public function getDatabase()
  {
    return $this->s_lastDatabase;
  }
}
